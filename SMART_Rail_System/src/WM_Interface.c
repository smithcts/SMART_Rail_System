/*
********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.28                          *
*        Compiled Jan 30 2015, 16:41:06                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************


// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "main.h"
********************************************************************
*
*       Defines
*
**********************************************************************

#define ID_FRAMEWIN_0    (GUI_ID_USER + 0x00)
#define ID_BUTTON_0    (GUI_ID_USER + 0x02)
#define ID_BUTTON_1    (GUI_ID_USER + 0x03)
#define ID_BUTTON_2    (GUI_ID_USER + 0x04)
#define ID_BUTTON_3    (GUI_ID_USER + 0x05)
#define ID_BUTTON_4    (GUI_ID_USER + 0x06)
#define ID_TEXT_0    (GUI_ID_USER + 0x07)
#define ID_TEXT_1    (GUI_ID_USER + 0x08)
#define ID_TEXT_2    (GUI_ID_USER + 0x09)

int PULSE1_VALUE = 200;
int PWM_START(int PULSE);
static void PWM_STOP();
static void Error_Handler(void);
TIM_HandleTypeDef MotorPWM;
TIM_OC_InitTypeDef sConfig;

// USER START (Optionally insert additional defines)
// USER END

********************************************************************
*
*       Static data
*
**********************************************************************


// USER START (Optionally insert additional static data)
// USER END

********************************************************************
*
*       _aDialogCreate

static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { FRAMEWIN_CreateIndirect, "Rail System", ID_FRAMEWIN_0, 	0, 0, 480, 272, 0, 0x0,  },
  { BUTTON_CreateIndirect, "Forward", 	ID_BUTTON_0, 		50, 80, 100, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Stop", 		ID_BUTTON_1, 		50, 120, 100, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Backward",	ID_BUTTON_2, 		50, 160, 100, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Increase", 	ID_BUTTON_3, 		280, 80, 80, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Decrease", 	ID_BUTTON_4, 		280, 160, 80, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "fe", 			ID_TEXT_0, 			260, 120, 80, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Far Limit", 	ID_TEXT_1, 			200, 20, 80, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Near Limit", 	ID_TEXT_2, 			300, 20, 80, 20, 0, 0x0, 0 },
  { CHECKBOX_CreateIndirect, 0,        GUI_ID_CHECK0,    	5,  30, 120,   0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

********************************************************************
*
*       Static code
*
**********************************************************************

******************************************************************
*
*       _DemoButton

static void _DemoButton(void) {
  BUTTON_Handle hButton;
  GUI_SetColor(GUI_BLACK);
  GUI_SetFont(&GUI_Font8x16);
  GUI_DispStringHCenterAt("Click on button...", 160, 90);
  //
  // Create the button and set text
  //
  hButton = BUTTON_Create(110, 110, 100, 40, GUI_ID_OK, WM_CF_SHOW);
  BUTTON_SetText(hButton, "Click me...");
  //
  // Let window manager handle the button
  //
  while (GUI_WaitKey() != GUI_ID_OK);
  //
  // Delete the button
  //
  BUTTON_Delete(hButton);
  GUI_ClearRect(0, 50, 319, 239);
  GUI_Delay(1000);
}
// USER START (Optionally insert additional static code)
// USER END

********************************************************************
*
*       _cbDialog



static void _cbDialog(WM_MESSAGE * pMsg) {
WM_HWIN hDlg, hItem;
BUTTON_Handle hButton;
  int NCode;
  int Id;
  // USER START (Optionally insert additional variables)
  // USER END
hDlg = pMsg->hWin;
  switch (pMsg->MsgId) {
	case WM_PAINT:
		GUI_SetColor(GUI_BLUE);
		GUI_Clear();
		GUI_DispStringAt("HEELO",40,40);
		GUI_DispDecAt(2,40,40,3);
		int Limit_Switch_1_State = 0;
		Limit_Switch_1_State = HAL_GPIO_ReadPin(GPIOI, GPIO_PIN_0);
		if (Limit_Switch_1_State == 1)
		{
			GUI_SetColor(GUI_GREEN);
			GUI_DrawRect(190,140,220,160);
			GUI_DispDecAt(Limit_Switch_1_State,200,150,2);
		}
		else
		{
			GUI_ClearRect(190,140,220,160);
			GUI_Clear();
		}

	break;
//	case WM_INIT_DIALOG:
//		hItem = WM_GetDialogItem(hDlg, GUI_ID_CHECK0);
//		CHECKBOX_SetText(hItem, "LIMIT");
//		if(HAL_GPIO_ReadPin(GPIOI,GPIO_PIN_0) == 1)
//		{
//		CHECKBOX_SetState(hItem,1);
//		}
//	break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Forward'
      switch(NCode) {
      case WM_NOTIFICATION_RELEASED:

		HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3,GPIO_PIN_SET);

		PWM_START(PULSE1_VALUE);

        break;
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'Stop'
      switch(NCode) {
      case WM_NOTIFICATION_RELEASED:

    	HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3,GPIO_PIN_RESET);

    	PWM_STOP();

        break;
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'Backward'
      switch(NCode) {
      case WM_NOTIFICATION_RELEASED:

			HAL_GPIO_WritePin(GPIOI,GPIO_PIN_3,GPIO_PIN_RESET);

			PWM_START(PULSE1_VALUE);

        break;
      }
      break;
    case ID_BUTTON_3: // Notifications sent by 'Increase'
      switch(NCode) {
      case WM_NOTIFICATION_RELEASED:
			PULSE1_VALUE = PULSE1_VALUE + 30;
			if (HAL_TIM_PWM_GetState(&MotorPWM) == 1)
			{
				PWM_START(PULSE1_VALUE);
			}
			else
			{
				PWM_STOP();
			}
        break;
      }
      break;
      case ID_BUTTON_4: // Notifications sent by 'Decrease'
        switch(NCode) {
        case WM_NOTIFICATION_RELEASED:
			PULSE1_VALUE = PULSE1_VALUE - 30;
			if (HAL_TIM_PWM_GetState(&MotorPWM) == 1)
			{
				PWM_START(PULSE1_VALUE);

			}
			else
			{
				PWM_STOP();
			}
          break;
        }
        break;
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}


********************************************************************
*
*       Public code
*
**********************************************************************

********************************************************************
*
*       CreateFramewin



void MainTask(void) {
  WM_HWIN hDlg, hText, hItem;
  WM_SetCreateFlags(WM_CF_MEMDEV);
  GUI_Init();
  char acText[3] = {0};
  acText[0] = PULSE1_VALUE;
  hDlg = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	    hText = WM_GetDialogItem(hDlg, ID_TEXT_0);
	TEXT_SetText(hText, acText);

	hItem = WM_GetDialogItem(hDlg, GUI_ID_CHECK0);
	CHECKBOX_SetText(hItem, "LIMIT");
	if(HAL_GPIO_ReadPin(GPIOI,GPIO_PIN_0) == 1)
	{
	CHECKBOX_SetState(hItem,1);
	}

  while (1) {

	    _DemoButton();
	  GUI_Delay(100);
  }
}

int PWM_START(int PULSE){
	 Set the pulse value for channel 1
	sConfig.Pulse = PULSE;
	if (HAL_TIM_PWM_ConfigChannel(&MotorPWM, &sConfig, TIM_CHANNEL_1) != HAL_OK)
	{
	 Configuration Error
	Error_Handler();
	}
	##-3- Start PWM signals generation #######################################
	 Start channel 1
	if (HAL_TIM_PWM_Start(&MotorPWM, TIM_CHANNEL_1) != HAL_OK)
	{
	 PWM Generation Error
	Error_Handler();
	}

	return 0;
}
static void PWM_STOP(){

	##-3- Start PWM signals generation #######################################
	 Start channel 1
	if (HAL_TIM_PWM_Stop(&MotorPWM, TIM_CHANNEL_1) != HAL_OK)
	{
	 PWM Generation Error
	Error_Handler();
	}
}
// Any errors will cause the LED to turn on.
static void Error_Handler(void)
{
   Turn LED1 on
  BSP_LED_On(LED1);
  while (1)
  {
  }
}


// USER START (Optionally insert additional public code)
// USER END

************************** End of file ***************************
*/
